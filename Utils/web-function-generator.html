<!DOCTYPE html>
<html>
<head>
    <title>Function Table Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <style>
        /* ... existing styles ... */
        body {
            font-family: system-ui, -apple-system, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .toolbar {
            grid-column: 1 / -1;
            display: flex;
            gap: 10px;
            padding-bottom: 20px;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background: #f8f8f8;
            border-radius: 8px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-weight: 500;
            color: #333;
        }
        input, select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #0056b3;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            height: 400px;
        }
        /* New styles for min/max display below chart */
        .min-max-display {
            grid-column: 2 / 3; /* Align with the chart column */
            display: flex;
            justify-content: space-around;
            padding: 10px 20px;
            background: #f8f8f8;
            border-radius: 0 0 8px 8px; /* Round bottom corners */
            margin-top: -20px; /* Overlap slightly with chart padding */
            position: relative; /* Needed for z-index */
            z-index: 1; /* Ensure it's above chart background if overlapping */
            font-size: 14px;
            color: #333;
            border: 1px solid #eee; /* Optional border */
            border-top: none; /* Remove top border */
        }
        .min-max-display span span { /* Style the actual value spans */
            font-weight: bold;
            margin-left: 5px;
            padding: 2px 5px;
            background: #eee;
            border-radius: 3px;
            min-width: 30px; /* Ensure some minimum width */
            display: inline-block; /* Allow padding/width */
            text-align: right;
        }
        .range-group {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 10px;
            align-items: center;
        }
        .range-group input[type="number"] {
            min-width: 0; /* Allows the input to shrink below its default minimum */
            width: 100%; /* Encourages the input to fill its grid column */
            box-sizing: border-box; /* Ensures padding/border are included in the width calculation */
        }
        .status {
            grid-column: 1 / -1; /* Ensure status spans full width */
            padding: 10px;
            margin-top: 20px;
            border-radius: 4px;
            display: none;
        }
        .status.success {
            display: block;
            background: #d4edda;
            color: #155724;
        }
        .status.error {
            display: block;
            background: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="toolbar">
            <button onclick="loadConfig()">Load Config</button>
            <button onclick="saveConfig()">Save Config</button>
            <button onclick="loadData()">Load Data</button>
            <button onclick="generateData()">Generate</button>
            <button onclick="saveData()">Save Data</button>
        </div>
        <div class="controls">
            <div class="control-group">
                <label for="function">Function:</label>
                <select id="function">
                    <option value="sin">SIN</option>
                    <option value="cos">COS</option>
                    <option value="custom">CUSTOM</option>
                </select>
            </div>
            <div class="control-group">
                <label>Range (degrees):</label>
                <div class="range-group">
                    <input type="number" id="rangeMin" value="0">
                    <span>to</span>
                    <input type="number" id="rangeMax" value="360">
                </div>
            </div>
            <div class="control-group">
                <label for="scale">Scale:</label>
                <input type="number" id="scale" value="32768">
            </div>
            <div class="control-group">
                <label for="entries">Number of entries:</label>
                <input type="number" id="entries" value="360">
            </div>
            <div class="control-group">
                <label for="size">Entry size (bits):</label>
                <select id="size">
                    <option value="8">8</option>
                    <option value="16" selected>16</option>
                    <option value="32">32</option>
                </select>
            </div>
        </div>
        <div class="chart-container">
            <canvas id="chart"></canvas>
        </div>
        <div class="min-max-display">
            <span>Min Value: <span id="minValueDisplay">N/A</span></span>
            <span>Max Value: <span id="maxValueDisplay">N/A</span></span>
        </div>
        <div id="status" class="status"></div>
    </div>

    <script>
        let chart = null;
        let generatedData = null;

        // --- Helper function for clamping ---
        function clampValue(value, size) {
            const roundedValue = Math.round(value);
            switch(size) {
                case 8:
                    // Clamp to valid unsigned 8-bit range
                    return Math.max(0, Math.min(255, roundedValue));
                case 16:
                    // Clamp to valid signed 16-bit range
                    return Math.max(-32768, Math.min(32767, roundedValue));
                case 32:
                    // Clamp to valid signed 32-bit range (JavaScript numbers are 64-bit floats,
                    // but DataView uses signed 32-bit integers)
                    // Note: Math.pow(2, 31) is slightly inaccurate due to float precision.
                    const minInt32 = -2147483648;
                    const maxInt32 = 2147483647;
                    return Math.max(minInt32, Math.min(maxInt32, roundedValue));
                default:
                    return roundedValue; // Should not happen with select options
            }
        }
        // --- End Helper ---

        function initChart() {
            const ctx = document.getElementById('chart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Generated Values',
                        data: [],
                        borderColor: '#007bff',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: false // Allow negative values for SIN/COS
                        }
                    }
                }
            });

            // --- Add event listener for size change ---
            document.getElementById('size').addEventListener('change', handleSizeChange);
            // --- End Add event listener ---
        }

        // --- New function to handle size change ---
        function handleSizeChange() {
            if (generatedData) {
                generatedData = null; // Invalidate existing data
                updateChart([], [], 'No Data'); // Clear the chart
                updateMinMaxDisplay([]); // Clear min/max display
                showStatus('Entry size changed. Please regenerate data.', 'success'); // Use 'success' or a neutral style
            }
        }
        // --- End New function ---

        function generateData() {
            const func = document.getElementById('function').value;
            const minDeg = parseFloat(document.getElementById('rangeMin').value);
            const maxDeg = parseFloat(document.getElementById('rangeMax').value);
            const scale = parseFloat(document.getElementById('scale').value);
            const entries = parseInt(document.getElementById('entries').value);
            const size = parseInt(document.getElementById('size').value); // Get selected size

            if (isNaN(minDeg) || isNaN(maxDeg) || isNaN(scale) || isNaN(entries) || entries <= 1) {
                 showStatus('Invalid input parameters.', 'error');
                 return;
            }
            if (maxDeg <= minDeg && entries > 1) {
                 showStatus('Max range must be greater than min range.', 'error');
                 return;
            }

            // Generate x values (degrees)
            const step = entries > 1 ? (maxDeg - minDeg) / (entries - 1) : 0; // Avoid division by zero if entries = 1
            const degrees = Array.from({length: entries}, (_, i) => minDeg + i * step);

            // Generate y values
            generatedData = degrees.map(deg => {
                const rad = deg * Math.PI / 180;
                let val;
                switch(func) {
                    case 'sin': val = Math.sin(rad); break;
                    case 'cos': val = Math.cos(rad); break;
                    default: val = 0; // Handle custom case if needed, or default
                }
                const scaledValue = val * scale;
                // --- Clamp the value based on the selected size ---
                return clampValue(scaledValue, size);
                // --- End Clamp ---
            });

            updateChart(degrees, generatedData, `${func.toUpperCase()} Values (${size}-bit)`); // Add size to title
            showStatus('Data generated successfully!', 'success');
        }

        function updateChart(labels, data, title) {
            if (!chart) return; // Ensure chart is initialized
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.data.datasets[0].label = title;
            chart.update();

            updateMinMaxDisplay(data);
        }

        function updateMinMaxDisplay(dataArray) {
            const minDisplay = document.getElementById('minValueDisplay');
            const maxDisplay = document.getElementById('maxValueDisplay');

            if (!dataArray || dataArray.length === 0) {
                minDisplay.textContent = 'N/A';
                maxDisplay.textContent = 'N/A';
            } else {
                // Calculate min and max from the array
                // Since data is already clamped, Math.min/max is safe
                const minValue = Math.min(...dataArray);
                const maxValue = Math.max(...dataArray);

                minDisplay.textContent = minValue;
                maxDisplay.textContent = maxValue;
            }
        }

        function loadData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.dat';
            input.onchange = async e => {
                const file = e.target.files[0];
                if (!file) return;

                const buffer = await file.arrayBuffer();
                const size = parseInt(document.getElementById('size').value); // Use current size setting for reading
                const bytesPerEntry = size / 8;

                if (buffer.byteLength === 0 || buffer.byteLength % bytesPerEntry !== 0) {
                    showStatus(`Error loading data: File size (${buffer.byteLength}) is not a multiple of selected entry size (${bytesPerEntry} bytes).`, 'error');
                    return;
                }

                const entries = buffer.byteLength / bytesPerEntry;

                try {
                    const view = new DataView(buffer);
                    generatedData = new Array(entries);
                    let minVal = Infinity; // Renamed for clarity
                    let maxVal = -Infinity; // Renamed for clarity

                    // Read the data based on entry size
                    for(let i = 0; i < entries; i++) {
                        const offset = i * bytesPerEntry;
                        let value;
                        switch(size) {
                            case 8:
                                // Assuming loaded 8-bit data is unsigned as per save logic
                                value = view.getUint8(offset);
                                break;
                            case 16:
                                value = view.getInt16(offset, false); // false = big-endian
                                break;
                            case 32:
                                value = view.getInt32(offset, false); // false = big-endian
                                break;
                            default:
                                throw new Error(`Unsupported entry size: ${size}`);
                        }
                        generatedData[i] = value;
                        minVal = Math.min(minVal, value);
                        maxVal = Math.max(maxVal, value);
                    }

                    document.getElementById('function').value = 'custom'; // Mark as custom since it's loaded
                    document.getElementById('entries').value = entries;
                    // Estimate scale based on max absolute value found in the data
                    const estimatedScale = Math.max(Math.abs(minVal), Math.abs(maxVal));
                    document.getElementById('scale').value = estimatedScale > 0 ? estimatedScale : 1; // Avoid scale 0
                    document.getElementById('rangeMin').value = 0;
                    document.getElementById('rangeMax').value = entries - 1; // Use index as label

                    // Update chart with loaded data (using index as label)
                    const labels = Array.from({length: entries}, (_, i) => i);
                    updateChart(labels, generatedData, `Loaded Data (${size}-bit)`); // Add size to title
                    showStatus(`Loaded ${entries} entries successfully!`, 'success');
                } catch (error) {
                    showStatus('Error loading data: ' + error.message, 'error');
                    // Clear potentially inconsistent state
                    generatedData = null;
                    updateChart([], [], 'No Data');
                    updateMinMaxDisplay([]);
                }
            };
            input.click();
        }

        function saveData() {
            if (!generatedData || generatedData.length === 0) {
                showStatus('No data generated or loaded yet!', 'error');
                return;
            }

            const size = parseInt(document.getElementById('size').value);
            const bytesPerEntry = size / 8;
            const buffer = new ArrayBuffer(generatedData.length * bytesPerEntry);
            const view = new DataView(buffer);

            try {
                generatedData.forEach((value, i) => {
                    const offset = i * bytesPerEntry;
                    switch(size) {
                        case 8:
                            // Value should already be in 0-255 range
                            view.setUint8(offset, value);
                            break;
                        case 16:
                             // Value should already be in -32768 to 32767 range
                            view.setInt16(offset, value, false); // false = big-endian
                            break;
                        case 32:
                             // Value should already be in -2^31 to 2^31-1 range
                            view.setInt32(offset, value, false); // false = big-endian
                            break;
                         default:
                            throw new Error(`Unsupported entry size: ${size}`);
                    }
                });

                const blob = new Blob([buffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const funcName = document.getElementById('function').value;
                const entries = document.getElementById('entries').value;
                a.download = `${funcName}_${entries}_${size}.dat`;
                a.click();
                URL.revokeObjectURL(url);

                showStatus('Data saved successfully!', 'success');
            } catch (error) {
                showStatus('Error saving data: ' + error.message, 'error');
            }
        }

        function saveConfig() {
            const config = {
                function: document.getElementById('function').value,
                rangeMin: document.getElementById('rangeMin').value,
                rangeMax: document.getElementById('rangeMax').value,
                scale: document.getElementById('scale').value,
                entries: document.getElementById('entries').value,
                size: document.getElementById('size').value
            };

            const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'function_config.cfg';
            a.click();
            URL.revokeObjectURL(url);

            showStatus('Configuration saved successfully!', 'success');
        }

        function loadConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.cfg, .json';
            input.onchange = e => {
                const file = e.target.files[0];
                 if (!file) return;
                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const config = JSON.parse(event.target.result);
                        const previousSize = document.getElementById('size').value; // Get size before loading
                        document.getElementById('function').value = config.function ?? 'sin';
                        document.getElementById('rangeMin').value = config.rangeMin ?? 0;
                        document.getElementById('rangeMax').value = config.rangeMax ?? 360;
                        document.getElementById('scale').value = config.scale ?? 32768;
                        document.getElementById('entries').value = config.entries ?? 360;
                        document.getElementById('size').value = config.size ?? 16;

                        // If size changed during load, invalidate old data before generating new
                        if (generatedData && document.getElementById('size').value !== previousSize) {
                             generatedData = null;
                             updateChart([], [], 'No Data');
                             updateMinMaxDisplay([]);
                        }

                        showStatus('Configuration loaded successfully! Regenerating data...', 'success');
                        // Use setTimeout to allow the status message to render before potentially blocking generation
                        setTimeout(generateData, 50);
                    } catch (error) {
                        showStatus('Error loading configuration: ' + error.message, 'error');
                    }
                };
                 reader.onerror = () => {
                     showStatus('Error reading configuration file.', 'error');
                 };
                reader.readAsText(file);
            };
            input.click();
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            if (status.timeoutId) {
                clearTimeout(status.timeoutId);
            }
            status.timeoutId = setTimeout(() => {
                status.className = 'status';
                status.timeoutId = null;
            }, 5000);
        }

        // Initialize chart on load
        window.onload = initChart;
    </script>
</body>
</html>
